## diff算法

### 无key的情况下

如果无key，那么diff算法就只有三个步骤：

第一步：patch的时候会根据顺序使用新的节点替换掉旧的节点。

第二步：如果发现新的节点有多的，就会做新增的操作，插入这个新的节点。

第三步：如果新的节点比旧的节点少，就会删除旧的节点。

### 有key的情况下

在有key的情况下：

第一步：会先进行 前序对比算法，先从头部开始对比新旧节点是否一样，如果一样就会复用，如果不一样，就会break，

第二步：之后进行 尾序对比算法，从尾部对比新旧节点是否一样，如果一样也会复用，如果不一样，就break，

第三步：新节点如果多出来了，就会挂载上去，

第四步：旧节点如果多出来就会卸载，

第五步：特殊情况乱序： 先构建新节点的映射关系，然后记录新节点在旧节点中的位置数组，然后对比，如果有多余的旧节点就删除，如果新节点不包含旧节点也删除，如果节点出现交叉，说明是要移动，要去求最长递增子序列，求最长递增子序列升序，求出来之后，如果当前遍历的节点不在子序列中就说明要进行移动，如果节点在序列中就直接跳过。